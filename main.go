package main

import (
	"log"
	"os"
	"os/signal"
	"strconv"
	"syscall"
	"time"

	"github.com/ansrivas/fiberprometheus/v2"
	"github.com/gofiber/fiber/v2"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promauto"
	"github.com/yankeguo/rg"
	"github.com/yankeguo/snowid"
)

var (
	metricsGeneratorCount = promauto.NewCounter(prometheus.CounterOpts{
		Name: "snowid_generated",
		Help: "count of ids generated by snowid generator",
	})
)

func newGenerator() (g snowid.Generator, err error) {
	var opts snowid.Options

	if opts.ID, err = extractWorkerID(); err != nil {
		return
	}

	if epoch := os.Getenv("EPOCH"); epoch != "" {
		if opts.Epoch, err = time.ParseInLocation(
			"2006-01-02 15:04:05",
			epoch,
			time.UTC,
		); err != nil {
			return
		}
	} else {
		opts.Epoch = time.Date(2020, time.January, 1, 0, 0, 0, 0, time.UTC)
	}

	if grain := os.Getenv("GRAIN"); grain != "" {
		if opts.Grain, err = time.ParseDuration(grain); err != nil {
			return
		}
	} else {
		opts.Grain = time.Millisecond
	}

	opts.LeadingBit, _ = strconv.ParseBool(os.Getenv("LEADING_BIT"))

	log.Println("WorkerID:", opts.ID)
	log.Println("Epoch:", opts.Epoch.String())
	log.Println("Grain:", opts.Grain.String())
	log.Println("LeadingBit:", opts.LeadingBit)

	return snowid.New(opts)
}

func main() {
	var err error
	defer func() {
		if err == nil {
			return
		}
		log.Println("exited with error:", err)
	}()
	defer rg.Guard(&err)

	// create generator
	g := rg.Must(newGenerator())
	defer g.Stop()

	// create application
	app := fiber.New()

	// health check
	app.Use(func(c *fiber.Ctx) error {
		if c.Path() == "/healthz" {
			g.NewID()
			return c.SendString("OK")
		}
		return c.Next()
	})

	// prometheus
	fp := fiberprometheus.New("snowid-service")
	fp.RegisterAt(app, "/metrics")
	app.Use(fp.Middleware)

	// snowid
	app.Get("/*", func(c *fiber.Ctx) error {
		size := c.QueryInt("size", 1)
		if size < 1 {
			size = 1
		}

		metricsGeneratorCount.Add(float64(size))

		var response []string
		for i := 0; i < size; i++ {
			response = append(response, strconv.FormatUint(g.NewID(), 10))
		}

		c.Response().Header.Set("Expires", "0")
		c.Response().Header.Set("Cache-Control", "no-cache, no-store, max-age=0, must-revalidate")

		return c.JSON(response)
	})

	// setup grace shutdown
	chErr := make(chan error, 1)
	chSig := make(chan os.Signal, 1)
	signal.Notify(chSig, syscall.SIGINT, syscall.SIGTERM)

	go func() {
		bind := os.Getenv("BIND")
		port := os.Getenv("PORT")
		if port == "" {
			port = "8080"
		}
		chErr <- app.Listen(bind + ":" + port)
	}()

	select {
	case err = <-chErr:
		return
	case sig := <-chSig:
		log.Println("received signal:", sig.String())
	}

	time.Sleep(time.Second * 3)

	app.ShutdownWithTimeout(time.Second * 3)
}
